{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":6776122041449728016,"abi":{"parameters":[{"name":"x","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"1dzBahtnFIbhe9Hai/m+oxmNciulBCdxgsDYIXYKJeTe67auW9qSTaHk2Xmk3+LnbN6FdJ4vh3c3bz5/eH25e3//cHj1w5fD7f3b68fL/d3T05fD8ttLDx+v7359eni8/vR4eLWerw43d+8Or07716vD+8vtzdOfy9erfxzc92V5Prrvx/XPw/mXw8d9fT57PM+3j255ucKW7fRyuNvXH68O+U7vnLzcOX+/c8E5z/935/W8/3GPZfsvcz5+p3f+1pxXcM4bOOcTOOcdnPMZnHMWcNCJOOmKkxZbGDGGEWsYMYcRexgxiBGLWLGIFYtYsYgVi1ixiBWLWLGIFYtYsYgVizhiEUcs4ohFHLGIIxZxxCKOWMQRizhiEUcs4lEs4lEs4lEs4pH8BlEs4lEs4lEs4lEs4lEs4lEs4ioWcRWLuIpFXMUirmIRV7GIq1jEVSziKhZxFYu4iUXcxCJuYhE3sYibWMSN/J2pWMRNLOImFnETi3gSi3gSi3gSi3gSi3gSi3gSi3giVy/EIp7EIp7EIu5iEXexiLtYxF0s4i4WcReLuItF3MltRLGIu1jEs1jEs1jEs1jEs1jEs1jEs1jEs1jEs1jEM7mgb27okyv6C7mjv5BL+gu5pb+IWcxC7ukv5KL+Qm7qL+Sq/kK2EeVryDaagI0p2JiEjWnYmIiNqdiYjA3p2ISEbEJKNiEpm5CWTUjMJqRmE5KzCenZhARtQoo2IUmbkKZNSNQmpGoTkrUJ6dqEhG1CyjYhaZuQtk1I3CakbhOStwnp24QEbkIKNyGJm5DGTUjkJqRyE5K5CenchIRuQko3IambkNZNSOwmpHYTkrsJ6d2EBG9CijchyZuQ5k1I9CakehOSvQnp3oSEb0LKNyHpm5D2TUj8JqR+E5K/CenfhARwQgo4IQmckAZOSAQnpIITksEJ6eCEhHBCSjghKZyQFk5IDCekhhOSwwnp4YQEcUKKOCFJnJAmTkgUJ6SKE5LFCenilHRxSro4JV2cki5OF7GNJV2cki5OSRenpItT0sUp6eKUdHFKujglXZySLk5JF6eki1PSxSnp4pR0cUq6OCVdnJIuTkkXp6SLU9LFKenilHRxSro4JV2cki5OSRenpItT0sUp6eKUdHFKujglXZySLk5JF6eki1PSxSnp4pR0cUq6OCVdnJIuTkkXp6SLU9LFKenilHRxSro4JV2cki5OSRenpItT0sUp6eKUdHFKujglXZySLk5JF6eki1PSxSnp4pR0cUq6OCVdnJIuTkkXp6SLU9LFKenilHRxSro4JV2cki5OSRenpItT0sUp6eKUdHFKujglXZySLk5JF6eki1PSxSnp4pR0cUq6OCVdnJIuTkkXp6SLU9LFKenilHRxhnRxhnRxhnRxhnRxZhHbOKSLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6SLM6CL8/Tw5tPl9vby4fXt/dvrx8v93cPTvz69/NP1p8v1m9ub58f3n+/e/uXdx58//v7O00f8Ag==","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"70":{"source":"pub fn main(x: pub [Field; 1]) -> pub Field {\n  let hash = mimc::mimc_bn254(x);\n  hash\n}\n","path":"/Users/autoparallel/Code/obi-wan/noir_examples/test_mimc/src/main.nr"},"71":{"source":"use std::hash::Hasher;\nuse std::default::Default;\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\npub fn mimc<let N: u32>(x: Field, k: Field, constants: [Field; N], exp: Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1..constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    }\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS: u32 = 91;\n//generated from seed \"mimc\" using keccak256 \nglobal MIMC_BN254_CONSTANTS: [Field; MIMC_BN254_ROUNDS] = [\n        0,\n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533\n    ];\n\n//mimc implementation with hardcoded parameters for BN254 curve.\n#[field(bn254)]\npub fn mimc_bn254<let N: u32>(array: [Field; N]) -> Field {\n    let exponent = 7;\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, MIMC_BN254_CONSTANTS, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n\npub struct MimcHasher {\n    _state: [Field],\n}\n\nimpl Hasher for MimcHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let exponent = 7;\n        let mut r = 0;\n        for i in 0..self._state.len() {\n            let h = mimc(self._state[i], r, MIMC_BN254_CONSTANTS, exponent);\n            r = r + self._state[i] + h;\n        }\n        r\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for MimcHasher {\n    fn default() -> Self {\n        MimcHasher { _state: &[] }\n    }\n}\n\nmod tests {\n    use super::mimc_bn254;\n\n    #[test]\n    fn smoke_test() {\n        let input = [12, 45, 78, 41];\n        let expected_output = 18226366069841799622585958305961373004333097209608110160936134895615261821931;\n        assert_eq(mimc_bn254(input), expected_output);\n    }\n}\n","path":"/Users/autoparallel/nargo/github.com/noir-lang/mimcv0.1.0/src/lib.nr"}},"names":["main"],"brillig_names":[]}